好的。这个问题的解决过程很有代表性，从一个看似简单的 `.gitignore` 错误，深入到一个核心的性能瓶颈，最终通过一个精巧的方案完美解决。这个过程值得在提交信息中被详细记录。

这是最终的提交计划。

我将直接生成 `git commit` 指令，你可以复制并执行。

---

### Script

#### Acts 1: 提交最终修复

~~~~~act
git_add
packages/quipu-engine/src/quipu/core/git_db.py
~~~~~

~~~~~act
git_commit
~~~~~
~~~~~
fix(engine): 彻底修复 `get_tree_hash` 的性能与 .gitignore 兼容性问题

本次提交解决了一个在大型代码库（如 Linux 内核）中暴露出的严重性能瓶颈和鲁棒性问题。`quipu save` 和 `quipu ui` 等命令的执行时间从 10-20 秒急剧下降至 1 秒以内。

### 问题根源

`get_tree_hash` 方法为了隔离性，使用了“影子索引” (`.quipu/tmp_index`)。此前的实现每次都从一个空白的索引开始，并执行 `git add -A`。

在大型仓库中，这强制 Git 放弃所有缓存和优化，必须从磁盘完整地读取、压缩和哈希**每一个**文件来从零构建索引。这个过程产生了巨大的 I/O 和 CPU 开销，是导致性能雪崩的根本原因。

此外，这个实现也无法正确处理项目中 `.gitignore` 文件忽略了 `.quipu` 目录本身的情况，导致命令在某些仓库中直接崩溃。

### 解决方案：“复制+更新”策略

新的实现采用了“复制+更新” (copy-on-write) 的策略，这是一种既高效又正确的方案：

1.  **复制 (Warm-up)**: `shadow_index` 上下文管理器不再从空白开始，而是首先将用户项目现有的 `.git/index` 文件复制到临时位置。这是一个毫秒级的操作，为我们提供了一个包含绝大部分正确信息的“温热”索引。

2.  **更新 (Catch-up)**: 接着，我们仍然在这个“温热”的索引上运行 `git add -A`。但此时，它的工作量从“处理数万个文件”急剧下降到“只处理用户未暂存的少数几个变更”，执行速度变得极快。

3.  **清理 (Safety Net)**: 最后，`git rm --cached -r .quipu` 作为一个绝对可靠的安全措施被保留，确保 Quipu 自身的数据绝不会被计入状态快照。

这个方案不仅将性能提升了超过一个数量级，也从根本上解决了与 `.gitignore` 的冲突问题，显著增强了 Quipu 在真实、复杂项目环境中的鲁棒性。
~~~~~
